# -*- coding: utf-8 -*-
"""22234103389.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nc4KCMALvPvnIUuqr-daZ6Wa6puWCm4y
"""

import matplotlib.pyplot as plt
import numpy as np

# ----- Helper Functions -----
def translate(points, tx, ty):
    """Translation of points by tx, ty"""
    T = np.array([
        [1, 0, tx],
        [0, 1, ty],
        [0, 0, 1]
    ])
    return (T @ points.T).T

def scale(points, sx, sy):
    """Scaling of points by sx, sy"""
    S = np.array([
        [sx, 0, 0],
        [0, sy, 0],
        [0, 0, 1]
    ])
    return (S @ points.T).T

def rotate(points, angle):
    """Rotation of points by given angle (in degrees)"""
    rad = np.radians(angle)
    R = np.array([
        [np.cos(rad), -np.sin(rad), 0],
        [np.sin(rad),  np.cos(rad), 0],
        [0, 0, 1]
    ])
    return (R @ points.T).T


# ----- Example Shape: A Triangle -----
triangle = np.array([
    [0, 0, 1],
    [1, 0, 1],
    [0.5, 1, 1],
    [0, 0, 1]   # closing the triangle
])

# ----- Apply Transformations -----
triangle_translated = translate(triangle, 2, 1)
triangle_scaled = scale(triangle, 2, 1.5)
triangle_rotated = rotate(triangle, 45)

# ----- Plot Results -----
plt.figure(figsize=(8, 8))
plt.plot(triangle[:, 0], triangle[:, 1], 'b-', label="Original")
plt.plot(triangle_translated[:, 0], triangle_translated[:, 1], 'r--', label="Translated")
plt.plot(triangle_scaled[:, 0], triangle_scaled[:, 1], 'g--', label="Scaled")
plt.plot(triangle_rotated[:, 0], triangle_rotated[:, 1], 'm--', label="Rotated")

plt.legend()
plt.grid(True)
plt.axis("equal")
plt.title("Geometric Transformations of a Triangle")
plt.show()

"""1. Single Transform: Apply rotation of 45° to a triangle centered at origin. Record new
vertex coordinates. Show steps (matrix multiplication).
"""

import numpy as np
import matplotlib.pyplot as plt

# ----- Rotation Function -----
def rotate(points, angle):
    """Rotate points about origin by given angle (degrees)"""
    rad = np.radians(angle)
    R = np.array([
        [np.cos(rad), -np.sin(rad), 0],
        [np.sin(rad),  np.cos(rad), 0],
        [0, 0, 1]
    ])
    return (R @ points.T).T

# ----- Original Triangle -----
triangle = np.array([
    [0, 0, 1],   # A
    [1, 0, 1],   # B
    [0.5, 1, 1], # C
    [0, 0, 1]    # closing back to A
])

# ----- Apply Rotation (45°) -----
rotated_triangle = rotate(triangle, 45)

# ----- Print Step-by-Step Results -----
print("Original Coordinates:")
print(triangle[:, :2])

print("\nRotated Coordinates (45° about origin):")
print(rotated_triangle[:, :2])

# ----- Plot -----
plt.figure(figsize=(6, 6))
plt.plot(triangle[:, 0], triangle[:, 1], 'bo-', label="Original")
plt.plot(rotated_triangle[:, 0], rotated_triangle[:, 1], 'r--o', label="Rotated 45°")

plt.legend()
plt.grid(True)
plt.axis("equal")
plt.title("Rotation of Triangle by 45° about Origin")
plt.show()

"""2. Order Matters: Demonstrate that scaling then translation ≠ translation then scaling. Pick
a rectangle and show coordinates of both orders. Explain result.
"""

import numpy as np
import matplotlib.pyplot as plt

# --- Helper functions ---
def scale(points, sx, sy):
    S = np.array([[sx, 0, 0],
                  [0, sy, 0],
                  [0,  0, 1]])
    return (S @ points.T).T

def translate(points, tx, ty):
    T = np.array([[1, 0, tx],
                  [0, 1, ty],
                  [0, 0,  1]])
    return (T @ points.T).T

# --- Original rectangle (homogeneous coordinates) ---
rect = np.array([
    [0, 0, 1],   # A
    [2, 0, 1],   # B
    [2, 1, 1],   # C
    [0, 1, 1],   # D
    [0, 0, 1]    # close
], dtype=float)

# Transform parameters
sx, sy = 2.0, 0.5   # scale factors
tx, ty = 3.0, 1.0   # translation

# --- Order 1: Scale then Translate ---
rect_scaled = scale(rect, sx, sy)
rect_ST = translate(rect_scaled, tx, ty)

# --- Order 2: Translate then Scale ---
rect_translated = translate(rect, tx, ty)
rect_TS = scale(rect_translated, sx, sy)

# --- Print coordinates ---
print("Original Rectangle:")
print(rect[:, :2])

print("\nScale → Translate (S then T):")
print(rect_ST[:, :2])

print("\nTranslate → Scale (T then S):")
print(rect_TS[:, :2])

# --- Plot results ---
plt.figure(figsize=(7,7))
plt.plot(rect[:,0], rect[:,1], 'b-', label="Original")
plt.plot(rect_ST[:,0], rect_ST[:,1], 'r--', label="Scale→Translate")
plt.plot(rect_TS[:,0], rect_TS[:,1], 'g--', label="Translate→Scale")

plt.legend()
plt.grid(True)
plt.axis("equal")
plt.title("Order Matters: Scaling vs Translation")
plt.show()

"""3. Combined Transform: Using sliders, set a combination that maps the triangle into a
region near (2, -1) that is twice larger and rotated by -30°. Write the composed transform
matrix and final coordinates.
"""

import numpy as np
import matplotlib.pyplot as plt

# Original triangle
triangle = np.array([
    [0, 0, 1],
    [1, 0, 1],
    [0.5, 1, 1],
    [0, 0, 1]   # close
])

# Scaling (2x larger)
S = np.array([
    [2, 0, 0],
    [0, 2, 0],
    [0, 0, 1]
])

# Rotation (-30 degrees)
theta = np.radians(-30)
R = np.array([
    [np.cos(theta), -np.sin(theta), 0],
    [np.sin(theta),  np.cos(theta), 0],
    [0, 0, 1]
])

# Translation (2, -1)
T = np.array([
    [1, 0, 2],
    [0, 1, -1],
    [0, 0, 1]
])

# Combined transformation
M = T @ R @ S
print("Composed Transformation Matrix (M = T·R·S):\n", M, "\n")

# Apply transform
triangle_transformed = (M @ triangle.T).T
print("Final Transformed Coordinates (x, y):")
print(triangle_transformed[:, :2])

# --- Plotting ---
plt.figure(figsize=(7,7))
plt.plot(triangle[:,0], triangle[:,1], 'bo-', label="Original Triangle")
plt.plot(triangle_transformed[:,0], triangle_transformed[:,1], 'r--o', label="Transformed Triangle")

plt.grid(True)
plt.axis("equal")
plt.legend()
plt.title("Combined Transform: Scale + Rotate(-30°) + Translate(2,-1)")
plt.show()

"""4. Extra: Implement shear matrix and observe effect (optional)."""

import numpy as np
import matplotlib.pyplot as plt

# Original triangle
triangle = np.array([
    [0, 0, 1],
    [1, 0, 1],
    [0.5, 1, 1],
    [0, 0, 1]   # close
])

# Define shear factors
sh_x, sh_y = 0.5, 0.0   # shear in x-direction

# Shear matrix
Sh = np.array([
    [1, sh_x, 0],
    [sh_y, 1, 0],
    [0, 0, 1]
])

# Apply shear
triangle_sheared = (Sh @ triangle.T).T

print("Shear Matrix:\n", Sh, "\n")
print("Sheared Coordinates (x, y):\n", triangle_sheared[:, :2])

# Plot
plt.figure(figsize=(7,7))
plt.plot(triangle[:,0], triangle[:,1], 'bo-', label="Original Triangle")
plt.plot(triangle_sheared[:,0], triangle_sheared[:,1], 'g--o', label="Sheared Triangle")

plt.grid(True)
plt.axis("equal")
plt.legend()
plt.title("Effect of Shear Transformation")
plt.show()